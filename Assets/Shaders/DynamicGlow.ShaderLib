FILEVERSION = 2.4.0.0;
PLATFORM = DX9;

RENDER_STATE RSC_0 {
  blendingFromSurface = true;
  rasterizerstylefromsurface = true;
  trackingmask = 768;

  //------ Blend State Group ------
  alphatestref = 64;

  //------ Depth Stencil Group ------

  //------ Rasterizer State Group ------

  //------ Tesselation State Group ------
}

RENDER_STATE RSC_1 {
  blendingFromSurface = true;
  rasterizerstylefromsurface = true;

  //------ Blend State Group ------
  blendenable = 255;
  alphatestref = 64;

  //------ Depth Stencil Group ------

  //------ Rasterizer State Group ------

  //------ Tesselation State Group ------
}

RENDER_STATE RSC_2 {
  blendingFromSurface = true;
  rasterizerstylefromsurface = true;

  //------ Blend State Group ------
  blendenable = 255;
  alphatestref = 64;

  //------ Depth Stencil Group ------

  //------ Rasterizer State Group ------

  //------ Tesselation State Group ------
}

SHADER UVScroll_ModColor_VertexColorMask {
  RenderStateContainerID = 0;
  IsAutoGenerated = false;
  UsesPermutationVariables = false;
  streammask = 17;
  RecompilationRequiredOnPlatforms = -162;
  supportedplatforms = 161;
  compileflags = 0;
  hs_controlpoints = 3;

  //------ Texture samplers ------
  numsamplers_vs = 0;
  numsamplers_hs = 0;
  numsamplers_ds = 0;
  numsamplers_gs = 0;
  numsamplers_ps = 1;
  SAMPLER_PS 0 = {
    samplername = "";
    texturetype = base_texture;
    textureindex = 0;
    texturefile = "";
    filtermode = default;
    textureaddressmode = wrap,wrap,wrap;
    m_fLodBias = 0.000000;
    m_iMaxAnisotropy = 16;
    comparisonfunc = less;
    bordercolor = 0.000000,0.000000,0.000000,1.000000;
    minlod = 0.000000;
    maxlod = 0.000000;
  }
  numsamplers_cs = 0;

  //------ vertex shader source ------

  vs_sourcecode=$SOURCECODETAG{
//
#include <Shaders/VisionCommon.inc>
#include <Shaders/ShaderHelpers.inc>

#ifdef _VISION_DX11
cbuffer g_GlobalConstantBufferFrame : register (b0)
{
  float4 DepthFog  : packoffset(c19);  // linear depth fog parameter: near, far, 1/(far-near)
  float TimeDelta  : packoffset(c16);
}
cbuffer g_GlobalConstantBufferObject : register (b1)
{
  float4x4 matMVP  : packoffset(c4);   // model view projection matrix
}
cbuffer g_GlobalConstantBufferUser : register (b2)
{  
  float2 UVSpeed   : packoffset(c0);
  float4 Color     : packoffset(c1);
}
#else
  float4x4 matMVP  : register(c8);
  float TimeDelta  : register(c30);
  
  float4 DepthFog  : register(c62);  // linear depth fog parameter: near, far, 1/(far-near)
  float2 UVSpeed   : register(c66);
  float4 Color     : register(c67);
#endif

struct VS_IN
{
  float3 ObjPos  : POSITION;
  float2 UV0     : TEXCOORD0;
};

struct VS_OUT
{
  float4 ProjPos : SV_Position;
  float4 Color   : COLOR0;
  float2 UV0     : TEXCOORD0;
  half FogCoord  : TEXCOORD1;
};

VS_OUT vs_main( VS_IN In )
{
  VS_OUT Out;
  Out.ProjPos = mul( matMVP, float4(In.ObjPos, 1.0f) );
  Out.Color = Color;
  Out.UV0 = In.UV0 + (UVSpeed * TimeDelta);    
  Out.FogCoord = GetFogCoord(DepthFog, Out.ProjPos.z);

  return Out;
}
  }$SOURCECODETAG

  vs_function = "vs_main";
  vs_mintarget = vs_2_0;
  vs_mintargetDX11 = vs_4_0;
  svs_mintarget = vs_2_0;
  svs_mintargetDX11 = vs_4_0;

  //------ hull shader source ------
  hs_mintarget = hs_5_0;

  //------ domain shader source ------
  ds_mintarget = ds_5_0;

  //------ geometry shader source ------
  gs_mintarget = gs_4_0;
  gs_mintargetDX11 = gs_4_0;

  //------ pixel shader source ------

  ps_sourcecode=$SOURCECODETAG{
//
#include <Shaders/VisionCommon.inc>
#include <Shaders/ShaderHelpers.inc>

#ifdef _VISION_DX11
cbuffer g_GlobalConstantBufferFrame : register (b0)
{
  float4             DepthFogCol        : packoffset(c20);  // linear depth fog color
}
  Texture2D <float4> BaseTexture        : register(t0);
  sampler            BaseTextureSampler : register(s0);
#else
  sampler2D          BaseTexture        : register(s0);
  float4             DepthFogCol        : register(c1);     // linear depth fog color
#endif

struct PS_IN
{
  float4 ProjPos : SV_Position;
  float4 Color   : COLOR0;
  float2 UV0     : TEXCOORD0;
  half FogCoord  : TEXCOORD1;
};

float4 ps_main( PS_IN In ) : SV_Target
{
  float4 diffuse = vTex2D(BaseTexture, BaseTextureSampler, In.UV0);   
  diffuse = float4(GetFogColor(diffuse.xyz, DepthFogCol.rgb, In.FogCoord), diffuse.a);
  diffuse *= In.Color;
  return diffuse;
}
  }$SOURCECODETAG

  ps_function = "ps_main";
  ps_mintarget = ps_2_0;
  ps_mintargetDX11 = ps_4_0;

  //------ compute shader source ------
  cs_mintarget = cs_5_0;

  //------ platform specific bytecode ------
}

SHADER PulsingGlow_ModColor {
  RenderStateContainerID = 1;
  IsAutoGenerated = false;
  UsesPermutationVariables = false;
  streammask = 17;
  RecompilationRequiredOnPlatforms = 0;
  supportedplatforms = 161;
  compileflags = 0;
  hs_controlpoints = 3;

  //------ Texture samplers ------
  numsamplers_vs = 0;
  numsamplers_hs = 0;
  numsamplers_ds = 0;
  numsamplers_gs = 0;
  numsamplers_ps = 0;
  numsamplers_cs = 0;

  //------ vertex shader source ------

  vs_sourcecode=$SOURCECODETAG{
//
#include <Shaders/VisionCommon.inc>
#include <Shaders/ShaderHelpers.inc>

#ifdef _VISION_DX11
cbuffer g_GlobalConstantBufferFrame : register (b0)
{
  float4 DepthFog    : packoffset(c19);  // linear depth fog parameter: near, far, 1/(far-near)
  float TimeDelta    : packoffset(c16);  
}
cbuffer g_GlobalConstantBufferObject : register (b1)
{
  float4x4 matMVP    : packoffset(c4);   // model view projection matrix
}
cbuffer g_GlobalConstantBufferUser : register (b2)
{  
  float PulseSpeed   : packoffset(c0);
  float PulseMinimum : packoffset(c1);
  float4 Color       : packoffset(c2);
}
#else
  float4x4 matMVP    : register(c8);
  float TimeDelta    : register(c30);
  
  float4 DepthFog    : register(c62);  // linear depth fog parameter: near, far, 1/(far-near)
  float PulseSpeed   : register(c66);
  float PulseMinimum : register(c67);
  float4 Color       : register(c68);
#endif

struct VS_IN
{
  float3 ObjPos  : POSITION;
  float2 UV0     : TEXCOORD0;
};

struct VS_OUT
{
  float4 ProjPos : SV_Position;
  float4 Color   : COLOR0;
  float2 UV0     : TEXCOORD0;
  half FogCoord  : TEXCOORD1;
};

VS_OUT vs_main( VS_IN In )
{
  VS_OUT Out;
  Out.ProjPos = mul( matMVP, float4(In.ObjPos, 1.0f) );
  float i = (0.5f + 0.5f * sin(TimeDelta * PulseSpeed)) * (1.0f - PulseMinimum) + PulseMinimum;
  Out.Color = float4(i, i, i, 1.f) * Color;
  Out.UV0 = In.UV0;    
  Out.FogCoord = GetFogCoord(DepthFog, Out.ProjPos.z);

  return Out;
}
  }$SOURCECODETAG

  vs_function = "vs_main";
  vs_mintarget = vs_2_0;
  vs_mintargetDX11 = vs_4_0;
  svs_mintarget = vs_2_0;
  svs_mintargetDX11 = vs_4_0;

  //------ hull shader source ------
  hs_mintarget = hs_5_0;

  //------ domain shader source ------
  ds_mintarget = ds_5_0;

  //------ geometry shader source ------
  gs_mintarget = gs_4_0;
  gs_mintargetDX11 = gs_4_0;

  //------ pixel shader source ------

  ps_sourcecode=$SOURCECODETAG{
//
#include <Shaders/VisionCommon.inc>
#include <Shaders/ShaderHelpers.inc>

#ifdef _VISION_DX11
cbuffer g_GlobalConstantBufferFrame : register (b0)
{
  float4             DepthFogCol        : packoffset(c20);  // linear depth fog color
}
  Texture2D <float4> BaseTexture        : register(t0);
  sampler            BaseTextureSampler : register(s0);
#else
  sampler2D          BaseTexture        : register(s0);
  float4             DepthFogCol        : register(c1);     // linear depth fog color
#endif

struct PS_IN
{
  float4 ProjPos : SV_Position;
  float4 Color   : COLOR0;
  float2 UV0     : TEXCOORD0;
  half FogCoord  : TEXCOORD1;
};

float4 ps_main( PS_IN In ) : SV_Target
{
  float4 diffuse = vTex2D(BaseTexture, BaseTextureSampler, In.UV0);   
  diffuse = float4(GetFogColor(diffuse.xyz, DepthFogCol.rgb, In.FogCoord), diffuse.a);
  diffuse *= In.Color;
  return diffuse;
}
  }$SOURCECODETAG

  ps_function = "ps_main";
  ps_mintarget = ps_2_0;
  ps_mintargetDX11 = ps_4_0;

  //------ compute shader source ------
  cs_mintarget = cs_5_0;

  //------ platform specific bytecode ------
}

SHADER PulsingGlow_CycleLookup_ModColor {
  RenderStateContainerID = 2;
  IsAutoGenerated = false;
  UsesPermutationVariables = false;
  streammask = 17;
  RecompilationRequiredOnPlatforms = -162;
  supportedplatforms = 161;
  compileflags = 0;
  hs_controlpoints = 3;

  //------ Texture samplers ------
  numsamplers_vs = 0;
  numsamplers_hs = 0;
  numsamplers_ds = 0;
  numsamplers_gs = 0;
  numsamplers_ps = 0;
  numsamplers_cs = 0;

  //------ vertex shader source ------

  vs_sourcecode=$SOURCECODETAG{
//
#include <Shaders/VisionCommon.inc>
#include <Shaders/ShaderHelpers.inc>

#ifdef _VISION_DX11
cbuffer g_GlobalConstantBufferFrame : register (b0)
{
  float4        DepthFog        : packoffset(c19);
  float4        GlobalTime      : packoffset(c16);  
}
cbuffer g_GlobalConstantBufferObject : register (b1)
{
  float4x4      matMVP          : packoffset(c4);
}
cbuffer g_GlobalConstantBufferUser : register (b2)
{
  float         CycleTime       : packoffset(c1);
} 
#else
  float4x4      matMVP          : register(c8);
  float4        GlobalTime      : register(c30);
  float4        DepthFog        : register(c62);
  float         CycleTime       : register(c69);
#endif

struct VS_IN
{
  float3 ObjPos     : POSITION;
  float2 UV0        : TEXCOORD0;
};

struct VS_OUT
{
  float4 ProjPos    : SV_Position;
  float2 UV0        : TEXCOORD0;
  half FogCoord     : TEXCOORD1;
  float Intensity   : TEXCOORD2;
};

VS_OUT vs_main( VS_IN In )
{
  VS_OUT Out;
  Out.ProjPos = mul( matMVP, float4(In.ObjPos, 1.0f) );
  Out.UV0 = In.UV0;    
  Out.FogCoord = GetFogCoord(DepthFog, Out.ProjPos.z);
  Out.Intensity = fmod(GlobalTime.x / CycleTime, 1.0f);

  return Out;
}
  }$SOURCECODETAG

  vs_function = "vs_main";
  vs_mintarget = vs_2_0;
  vs_mintargetDX11 = vs_4_0;
  svs_mintarget = vs_2_0;
  svs_mintargetDX11 = vs_4_0;

  //------ hull shader source ------
  hs_mintarget = hs_5_0;

  //------ domain shader source ------
  ds_mintarget = ds_5_0;

  //------ geometry shader source ------
  gs_mintarget = gs_4_0;
  gs_mintargetDX11 = gs_4_0;

  //------ pixel shader source ------

  ps_sourcecode=$SOURCECODETAG{
//
#include <Shaders/VisionCommon.inc>
#include <Shaders/ShaderHelpers.inc>

#ifdef _VISION_DX11
cbuffer g_GlobalConstantBufferFrame : register (b0)
{
  float4             DepthFogCol        : packoffset(c20);
}
  Texture2D <float4> BaseTexture        : register(t0);
  sampler            BaseTextureSampler : register(s0);
  sampler            PulseLookup        : register(s1);
#else
  sampler2D          BaseTexture        : register(s0);  
  sampler2D          PulseLookup        : register(s1);
  float4             DepthFogCol        : register(c1);
#endif

struct PS_IN
{
  float4 ProjPos    : SV_Position;
  float2 UV0        : TEXCOORD0;
  half FogCoord     : TEXCOORD1;
  float Intensity   : TEXCOORD2;
};

float4 ps_main( PS_IN In ) : SV_Target
{
  float4 diffuse = vTex2D(BaseTexture, BaseTextureSampler, In.UV0);
  float4 lookup = tex2D(PulseLookup, In.Intensity);
  diffuse = float4(GetFogColor(diffuse.xyz, DepthFogCol.rgb, In.FogCoord), diffuse.a);
  diffuse *= lookup;
  return diffuse;
}
  }$SOURCECODETAG

  ps_function = "ps_main";
  ps_mintarget = ps_2_0;
  ps_mintargetDX11 = ps_4_0;

  //------ compute shader source ------
  cs_mintarget = cs_5_0;

  //------ platform specific bytecode ------
}

//////////////////////////////////////////////////////////////////////////////

EFFECT UVScroll_ModColor_VertexColorMask {
  DESCRIPTION = {};
  PARAMCOMMENT={"Color","","1,1,1,1",float4,color,""};
  PARAMCOMMENT={"UVSpeed","","0,0",float2,none,""};
  TECHNIQUE "new_technique"
  {
    passes="UVScroll_ModColor_VertexColorMask";
    passtype = Auto;
    IsPermutationTechnique=false;
    IsAutoGenerated=false;
  }
}

EFFECT PulsingGlow_ModColor {
  DESCRIPTION = {};
  PARAMCOMMENT={"Color","","1,1,1,1",float4,color,""};
  PARAMCOMMENT={"PulseSpeed","","1",float,none,""};
  PARAMCOMMENT={"PulseMinimum","","0.5",float,none,""};
  TECHNIQUE "new_technique"
  {
    passes="PulsingGlow_ModColor";
    passtype = Auto;
    IsPermutationTechnique=false;
    IsAutoGenerated=false;
  }
}

EFFECT PulsingGlow_CycleLookup_ModColor {
  DESCRIPTION = {};
  PARAMCOMMENT={"Color","","1,1,1,1",float4,color,""};
  PARAMCOMMENT={"PulseLookup","","",texture,texturefile,"Lookup texture for the glow pulsing."};
  PARAMCOMMENT={"CycleTime","","1",float,none,"Time in seconds for one pulse cycle."};
  TECHNIQUE "new_technique"
  {
    passes="PulsingGlow_CycleLookup_ModColor";
    passtype = Auto;
    IsPermutationTechnique=false;
    IsAutoGenerated=false;
  }
}

